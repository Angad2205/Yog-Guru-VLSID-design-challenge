---
sidebar_position: 3
---

# Coffee machine CM4

This Coffee Machine CM4 slave project is running on the CM4 core.

It will be linked into SDRAM and will be embedded into the CM7 project.

The CM7 project will handle the loading of this CM4 project into SDRAM and launching of it.

# Main functionalities
- Main GUI based on LVGL with Vglite graphics acceleration
- Camera with 2D PxP graphics acceleration
- Display for the camera preview and LVGL GUI
- USB shell
- LED indicator
- Multicore with messaging and shared memory communication

# LVGL GUI screens and widgets
All the LVGL GUI screens and widgets are generated with NXP's GUI Guider tools.

Please refer the [GUI Guider home page](https://www.nxp.com/design/software/development-software/gui-guider) for more detailed information.

# LVGL and Vglite library
The LVGL and Vglite components are directly ported from RT1170 SDK and we didn't modify them in our solution.

Also the code for the LVGL GUI screens and widgets, which are generated by NXP's GUI guider, is not frequently changed.

To speed up the building of the whole project, we moved these components into one static library and linked the library into the CM4 application project.

This LVGL and Vglite library project is located in the "coffee_machine/lvgl_vglite_lib" folder.

# Boot sequence
Below is the core boot up flow:

- Board level initialization
- Framework initialization
- HAL devices registration
- Framework startup
- FreeRTOS scheduler startup

The `main()` entry of this project is located in "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp" file:

```c
int main(void)
{
    /* init the board */
    APP_BoardInit();
    ...
    /* init the framework*/
    APP_InitFramework();

    /* register the hal devices*/
    APP_RegisterHalDevices();

    /* start the framework*/
    APP_StartFramework();

    vTaskStartScheduler();
    for (;;)
    {
    } /* should never get here */
    return 0;
}
```

# Board level initialization
The board level initialization is implemented in the `APP_BoardInit()` entry which is located in the "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp" file.

Below is the main flow:
- MPU, Clock and Pins configuration
- Multicore manager init and slave startup
- Peripherals initialization

```c
void APP_BoardInit()
{
    BOARD_ConfigMPU();
    BOARD_BootClockRUN();
    BOARD_InitBootPins();

#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
    uint32_t startupData, i;
    mcmgr_status_t status;
    (void)MCMGR_Init();
    /* Get the startup data */
    do
    {
        status = MCMGR_GetStartupData(&startupData);
    } while (status != kStatus_MCMGR_Success);
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
    ...
    BOARD_MIPIPanelTouch_I2C_Init();
    BOARD_InitEDMA();
    Time_Init(1);
}
```

# LVGL image resource and icon resource loading
All the LVGL images, data, and icon data are merged into one continuous binary block with the 64 Bytes aligned of each image/icon.

The cm7 will load this resource binary block into the dedicated memory region `res_sh_mem`.

The below two functions will load each of these LVGL images and icons from this region during the boot.

Setup the LVGL images is implemented in "coffee_machine/cm4/generated/gui_guider.c":
```c
void setup_imgs(unsigned char *base)
{
    brewing_animimg_brewingf01.data = (base + 0);
    brewing_animimg_brewingf02.data = (base + 120000);
    brewing_animimg_brewingf03.data = (base + 240000);
    ....
}
```
Load the icons is implemented in "framework/hal/output/hal_output_ui_coffee_machine.c":
```c
void LoadIcons(void *base)
{
    s_Icons[ICON_PROGRESS_BAR] = (base + 0);

    s_Icons[ICON_VIRTUAL_FACE_BLUE]  = (base + 6720);
    s_Icons[ICON_VIRTUAL_FACE_GREEN] = (base + 364608);
    s_Icons[ICON_VIRTUAL_FACE_RED]   = (base + 722496);
    // Icons Total: 0x00107c40  1080384
}
```

# Framework managers
The below framework managers are enabled in the cm4 side with the following priorities:
- Low power manager
- Camera manager - P2
- Display manager - P2
- Multicore manager - P0
- Output manager - P1
- Input manager - P2

Where P0 is the highest priority and P3 is the least prioritized.

Please refer to the framework doc located in "framework/doc" for a more detailed description of these framework managers.

Framework initialization in "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp"
```c
int APP_InitFramework(void)
{
    int ret = 0;

    FWK_MANAGER_INIT(LpmManager, ret);
    FWK_MANAGER_INIT(CameraManager, ret);
    FWK_MANAGER_INIT(DisplayManager, ret);
#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
    FWK_MANAGER_INIT(MulticoreManager, ret);
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
    FWK_MANAGER_INIT(OutputManager, ret);
    FWK_MANAGER_INIT(InputManager, ret);

    return ret;
}
```

Framework startup in "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp"
```c
int APP_StartFramework(void)
{
    int ret = 0;

    FWK_MANAGER_START(LpmManager, 0, ret);
    FWK_MANAGER_START(CameraManager, CAMERA_MANAGER_TASK_PRIORITY, ret);
    FWK_MANAGER_START(DisplayManager, DISPLAY_MANAGER_TASK_PRIORITY, ret);
#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
    FWK_MANAGER_START(MulticoreManager, MULTICORE_MANAGER_TASK_PRIORITY, ret);
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
    FWK_MANAGER_START(OutputManager, OUTPUT_MANAGER_TASK_PRIORITY, ret);
    FWK_MANAGER_START(InputManager, INPUT_MANAGER_TASK_PRIORITY, ret);

    return ret;
}
```

# Framework HAL devices
The enabled HAL devices are configured in the "coffee_machine/cm4/board/board_define.h" file as shown below:
```c
#define ENABLE_GFX_DEV_Pxp
#define ENABLE_DISPLAY_DEV_LVGLCoffeeMachine
#define ENABLE_CAMERA_DEV_MipiGc2145
#define ENABLE_OUTPUT_DEV_RgbLed
#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
#define ENABLE_MULTICORE_DEV_MessageBuffer
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
#define ENABLE_INPUT_DEV_ShellUsb
#define ENABLE_OUTPUT_DEV_UiCoffeeMachine
#define ENABLE_LPM_DEV_Standby
```

The registration of the enabled HAL devices is implemented in the `APP_RegisterHalDevices(...)` function which is located in "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp":

```{note}
The `APP_RegisterHalDevices(...)` should be called after the framework initialization `APP_InitFramework(...)` and before framework startup `APP_StartFramework(...)`.
```

```c
int APP_RegisterHalDevices(void)
{
    int ret = 0;

    HAL_GFX_DEV_REGISTER(Pxp, ret);
    HAL_DISPLAY_DEV_REGISTER(LVGLCoffeeMachine, ret);
    HAL_CAMERA_DEV_REGISTER(MipiGc2145, ret);
#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
    HAL_MULTICORE_DEV_REGISTER(MessageBuffer, ret);
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
    HAL_OUTPUT_DEV_REGISTER(RgbLed, ret);
    HAL_INPUT_DEV_REGISTER(ShellUsb, ret);
    HAL_OUTPUT_DEV_REGISTER(UiCoffeeMachine, ret);
    HAL_LPM_DEV_REGISTER(Standby, ret);
#ifdef ENABLE_OUTPUT_DEV_AudioDump
    HAL_OUTPUT_DEV_REGISTER(AudioDump, ret);
#endif /* ENABLE_OUTPUT_DEV_AudioDump */
    /* Add new HAL device registrations here */

    return ret;
}
```

## MipiGc2145 camera HAL device
This HAL device driver is located in "framework/hal/camera/hal_camera_mipi_gc2145.c".

Below is the configuration of this camera device which is located in "coffee_machine/cm4/board/board_define.h".

```c
#ifdef ENABLE_CAMERA_DEV_MipiGc2145
#define CAMERA_DEV_MipiGc2145_BUFFER_COUNT 2
#define CAMERA_DEV_MipiGc2145_HEIGHT       600 // 720
#define CAMERA_DEV_MipiGc2145_WIDTH        800 // 1280
#define CAMERA_DEV_MipiGc2145_LEFT         0
#define CAMERA_DEV_MipiGc2145_TOP          0
#define CAMERA_DEV_MipiGc2145_RIGHT        799 // 1279
#define CAMERA_DEV_MipiGc2145_BOTTOM       599 // 719
#define CAMERA_DEV_MipiGc2145_ROTATE       kCWRotateDegree_0
#define CAMERA_DEV_MipiGc2145_FLIP         kFlipMode_None
#define CAMERA_DEV_MipiGc2145_SWAPBYTE     0
#define CAMERA_DEV_MipiGc2145_FORMAT       kPixelFormat_YUV1P444_RGB
#define CAMERA_DEV_MipiGc2145_BPP          4
#endif /* ENABLE_CAMERA_DEV_MipiGc2145 */
```

## PxP graphics HAL device
This HAL device driver is located in "framework/hal/misc/hal_graphics_pxp.c".

It represents the 2D graphics device to handle the 2D graphics operations.

## LVGLCoffeeMachine display HAL device
This HAL device driver is located in "framework/hal/display/hal_display_lvgl_coffeemachine.c".

Below is the configuration of this display device which is located in "coffee_machine/cm4/board/board_define.h".

```c
#ifdef ENABLE_DISPLAY_DEV_LVGLCoffeeMachine
#define DISPLAY_DEV_LVGLCoffeeMachine_BUFFER_COUNT 1
#define DISPLAY_DEV_LVGLCoffeeMachine_HEIGHT       640
#define DISPLAY_DEV_LVGLCoffeeMachine_WIDTH        480
#define DISPLAY_DEV_LVGLCoffeeMachine_StartX       80
#define DISPLAY_DEV_LVGLCoffeeMachine_StartY       50
#define DISPLAY_DEV_LVGLCoffeeMachine_LEFT         0
#define DISPLAY_DEV_LVGLCoffeeMachine_TOP          0
#define DISPLAY_DEV_LVGLCoffeeMachine_RIGHT        479
#define DISPLAY_DEV_LVGLCoffeeMachine_BOTTOM       639
#define DISPLAY_DEV_LVGLCoffeeMachine_ROTATE       kCWRotateDegree_270
#define DISPLAY_DEV_LVGLCoffeeMachine_FORMAT       kPixelFormat_RGB565
#ifdef ENABLE_CAMERA_DEV_MipiGc2145
#define DISPLAY_DEV_LVGLCoffeeMachine_SRCFORMAT kPixelFormat_YUV1P444_RGB
#else
#define DISPLAY_DEV_LVGLCoffeeMachine_SRCFORMAT kPixelFormat_UYVY1P422_RGB
#endif /* ENABLE_CAMERA_DEV_MipiGc2145 */
#define DISPLAY_DEV_LVGLCoffeeMachine_BPP 2
#endif /* ENABLE_DisplayDev_LVGLCoffeeMachine */
```

This LVGLCoffeeMachine-display-HAL-device will launch the main LVGL task loop for the UI flashing.

```c
static void _LvglTask(void *param)
{
#if LV_USE_LOG
    lv_log_register_print_cb(_PrintCb);
#endif /* LV_USE_LOG */

    lv_port_pre_init();
    lv_init();
    lv_port_disp_init();
    lv_port_indev_init();
    g_LvglInitialized = true;

    setup_imgs((unsigned char *)APP_LVGL_IMGS_BASE);
    setup_ui(&guider_ui);
    events_init(&guider_ui);
    custom_init(&guider_ui);
    while (1)
    {
        lv_task_handler();
        vTaskDelay(pdMS_TO_TICKS(5));
    }
}
```

It also handles the camera preview request from the framework in `HAL_DisplayDev_LVGLCoffeeMachine_Blit` function:

```c
hal_display_status_t HAL_DisplayDev_LVGLCoffeeMachine_Blit(const display_dev_t *dev, void *frame, int width, int height)
{
    hal_display_status_t ret = kStatus_HAL_DisplaySuccess;
    LOGI("++HAL_DisplayDev_LVGLCoffeeMachine_Blit");

    // Show the new frame.
    void *lcdFrameAddr             = s_LcdBuffer[0];
    static int camerPreviewLayerOn = 0;

    // enable camera preview layer in screen with camera preview.
    if (lv_scr_act() == guider_ui.home && g_PreviewMode == PREVIEW_MODE_CAMERA)
    {
        if (camerPreviewLayerOn == 0)
        {
            lv_enable_camera_preview(lcdFrameAddr, true);
            camerPreviewLayerOn = 1;
        }
    }
    else
    {
        // disable camera preview layer in screen without camera preview.
        if (camerPreviewLayerOn == 1)
        {
            camerPreviewLayerOn = 0;
            lv_enable_camera_preview(lcdFrameAddr, false);
        }
    }

    LOGI("--HAL_DisplayDev_LVGLCoffeeMachine_Blit");
    return ret;
}
```

## UiCoffeeMachine UI output HAL device
This HAL device driver is located in "framework/hal/output/hal_output_ui_coffee_machine.c".

The whole UI state machine is driven by this output HAL device with the below event sources:

 ### LVGL touch events

 All the event callbacks of the LVGL widget is implemented in "coffee_machine/cm4/generated/events_init.c".

 ### Vision and Voice algorithm inference result
 The vision and voice inference result is notified by the output manager with below `HAL_OutputDev_UiCoffeeMachine_InferComplete` operator:

```c
static hal_output_status_t HAL_OutputDev_UiCoffeeMachine_InferComplete(const output_dev_t *dev,output_algo_source_t source,void *inferResult)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;

    if (inferResult == NULL)
    {
        return error;
    }

    coffee_machine_screen_id_t currentScreenId = get_current_screen();

    if (currentScreenId == SCR_INVALID)
    {
        return error;
    }

    if (source == kOutputAlgoSource_Vision)
    {
        _InferComplete_Vision(dev, inferResult, currentScreenId);
    }
    else if (source == kOutputAlgoSource_Voice)
    {
        _InferComplete_Voice(dev, inferResult, currentScreenId);
    }

    return error;
}
```

## RgbLed output HAL device
This HAL device driver is located in "framework/hal/output/hal_output_rgb_led.c".

It will flash the RGB led with different pattern according to the `HAL_OutputDev_RgbLed_InferComplete` or `HAL_OutputDev_RgbLed_InputNotify` operators below:

```c
static hal_output_status_t HAL_OutputDev_RgbLed_InferComplete(const output_dev_t *dev, output_algo_source_t source, void *inferResult)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;
    uint32_t timerOn          = 0;
    _SetLedColor(APP_OutputDev_RgbLed_InferCompleteDecode(source, inferResult, &timerOn));

    if (timerOn != 0)
    {
        xTimerChangePeriod(OutputRgbTimer, pdMS_TO_TICKS(timerOn), 0);
    }
    return error;
}
```

```c
static hal_output_status_t HAL_OutputDev_RgbLed_InputNotify(const output_dev_t *dev, void *data)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;

    _SetLedColor(APP_OutputDev_RgbLed_InputNotifyDecode(data));

    return error;
}
```

## MessageBuffer multicore HAL device
This HAL device driver is located in "framework/hal/misc/hal_multicore_messageBuffer.c".

It handles the multicore messaging based on the multicore manager message buffer mechanism.

Please refer the "framework/docs/hal_devices/multicore.md" in the framework doc for the detailed description of this HAL device.

## ShellUsb input HAL device
This HAL device driver is located in "framework/hal/input/hal_input_shell_cdc.c".

It populates one USB CDC device and generates the shell.

This driver only includes one `weak` shell command registration function as below:

```c
__attribute__((weak)) void APP_InputDev_Shell_RegisterShellCommands(shell_handle_t shellContextHandle,  input_dev_t shellDev, input_dev_callback_t callback)
{
}
```

The application needs to overwrite this function to register the exactly shell commands.

You can find the implementation of this overwritten function for the `Coffee Machine` application from "coffee_machine/cm4/source/event_handler/smart_tlhmi_input_shell_commands.c":

```c
void APP_InputDev_Shell_RegisterShellCommands(shell_handle_t shellContextHandle, input_dev_t *shellDev, input_dev_callback_t callback)
{
    s_InputCallback            = callback;
    s_SourceShell              = shellDev;
    s_ShellHandle              = shellContextHandle;
    s_FrameworkRequest.respond = _FrameworkEventsHandler;

    if (s_ThingName == NULL)
    {
        APP_GetHexUniqueID(&s_ThingName);
    }

    SHELL_RegisterCommand(shellContextHandle, SHELL_COMMAND(version));
    ...
}
```

## Standby LPM HAL device
This HAL device driver is located in "framework/hal/misc/hal_lpm_standby.c".

Please refer to "framework/docs/hal_devices/low_power.md" in the framework doc for the detailed description of this LPM device.

This standby HAL device implements the standby mode of this application. The backlight will be turned off and the main display layer will be disabled.

```c
static void _EnterStandbyMode(void)
{
    LOGD("[Standby] Enter standby mode");
    BOARD_BacklightControl(0);
    lv_enable_ui_preview(0);
}
```

# Logging
Both the CM7 and CM4 projects are leveraging the [FreeRTOS logging library](https://www.freertos.org/logging.html).

The FreeRTOS logging library code is located in the logging folder where you can find the detailed document "coffee_machine/cm7/freertos/libraries/logging/README.md".

The CM7 and CM4 share the same low level LPUART12 peripheral for the logging output. The hardware semaphore mechanism is used to guarantee the concurrence access of LPUART12 peripheral.

They share the same low level timer to get the unified timestamp of the logging information.

## Logging Task Init
Application calls `xLoggingTaskInitialize(...)` API to create the logging task in the `main()` entry of this project is located in the "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp" file:

```c
xLoggingTaskInitialize(LOGGING_TASK_STACK_SIZE, LOGGING_TASK_PRIORITY, LOGGING_QUEUE_LENGTH);
```

## Logging Macros
The logging Macros are defined in "framework/inc/fwk_log.h".

All the modules should use these unified logging Macros for logging.

```c
#ifndef LOGV
#define LOGV(fmt, args...) {implement...}
...
#endif

#ifndef LOGD
#define LOGD(fmt, args...) {implement...}
#endif

#ifndef LOGI
#define LOGI(fmt, args...) {implement...}
#endif

#ifndef LOGE
#define LOGE(fmt, args...) {implement...}
#endif
```